package builder

import (
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/hashicorp/go-multierror"
	"github.com/vim-volt/volt/cmd/buildinfo"
	"github.com/vim-volt/volt/fileutil"
	"github.com/vim-volt/volt/lockjson"
	"github.com/vim-volt/volt/logger"
	"github.com/vim-volt/volt/pathutil"
)

type baseBuilder struct{}

func (builder *baseBuilder) installVimrcAndGvimrc(profileName, vimrcPath, gvimrcPath string, useVimrc, useGvimrc bool) error {
	// Save old vimrc file as {vimrc}.bak
	vimrcInfo, err := os.Stat(vimrcPath)
	if err != nil && !os.IsNotExist(err) {
		return err
	}
	vimrcExists := !os.IsNotExist(err)
	if vimrcExists {
		err = fileutil.CopyFile(vimrcPath, vimrcPath+".bak", make([]byte, vimrcInfo.Size()), vimrcInfo.Mode())
		if err != nil {
			return err
		}
	}
	defer os.Remove(vimrcPath + ".bak")

	// Install vimrc
	err = builder.installRCFile(
		profileName,
		pathutil.ProfileVimrc,
		vimrcPath,
		useVimrc,
	)
	if err != nil {
		return err
	}

	// Install gvimrc
	err = builder.installRCFile(
		profileName,
		pathutil.ProfileGvimrc,
		gvimrcPath,
		useGvimrc,
	)
	if err != nil {
		// Restore old vimrc
		if vimrcExists {
			err2 := os.Rename(vimrcPath+".bak", vimrcPath)
			if err2 != nil {
				return multierror.Append(err, err2)
			}
		} else {
			err2 := os.Remove(vimrcPath)
			if err2 != nil {
				return multierror.Append(err, err2)
			}
		}
		return err
	}
	return nil
}

func (builder *baseBuilder) installRCFile(profileName, srcRCFileName, dst string, install bool) error {
	src := filepath.Join(pathutil.RCDir(profileName), srcRCFileName)

	// Return error if destination file does not have magic comment
	if pathutil.Exists(dst) {
		// If the file does not have magic comment
		if !builder.hasMagicComment(dst) {
			if !pathutil.Exists(src) {
				return nil
			}
			return errors.New("'" + dst + "' does not have magic comment")
		}
	}

	// Remove destination (~/.vim/vimrc or ~/.vim/gvimrc)
	os.Remove(dst)
	if pathutil.Exists(dst) {
		return errors.New("failed to remove " + dst)
	}

	// Skip if use_vimrc/use_gvimrc is false or rc file does not exist
	if !install || !pathutil.Exists(src) {
		return nil
	}

	return builder.copyFileWithMagicComment(src, dst)
}

const magicComment = "\" NOTE: this file was generated by volt. please modify original file.\n"
const magicCommentNext = "\" Original file: %s\n\n"

// Return error if the magic comment does not exist
func (*baseBuilder) hasMagicComment(dst string) bool {
	r, err := os.Open(dst)
	if err != nil {
		return false
	}
	defer r.Close()

	magic := []byte(magicComment)
	read := make([]byte, len(magic))
	n, err := r.Read(read)
	if err != nil || n < len(magicComment) {
		return false
	}

	for i := range magic {
		if magic[i] != read[i] {
			return false
		}
	}
	return true
}

func (builder *baseBuilder) copyFileWithMagicComment(src, dst string) (err error) {
	r, err := os.Open(src)
	if err != nil {
		return
	}
	defer func() {
		if e := r.Close(); e != nil {
			err = e
		}
	}()

	os.MkdirAll(filepath.Dir(dst), 0755)
	w, err := os.Create(dst)
	if err != nil {
		return
	}
	defer func() {
		if e := w.Close(); e != nil {
			err = e
		}
	}()

	_, err = w.Write([]byte(magicComment))
	if err != nil {
		return
	}
	_, err = w.Write([]byte(fmt.Sprintf(magicCommentNext, src)))
	if err != nil {
		return
	}

	_, err = io.Copy(w, r)
	return
}

type actionReposResult struct {
	err   error
	repos *lockjson.Repos
	files buildinfo.FileMap
}

func (builder *baseBuilder) getCurrentProfileAndReposList(lockJSON *lockjson.LockJSON) (*lockjson.Profile, lockjson.ReposList, error) {
	// Find current profile
	profile, err := lockJSON.Profiles.FindByName(lockJSON.CurrentProfileName)
	if err != nil {
		// this must not be occurred because lockjson.Read()
		// validates that the matching profile exists
		return nil, nil, err
	}

	reposList, err := lockJSON.GetReposListByProfile(profile)
	return profile, reposList, err
}

func (builder *baseBuilder) helptags(reposPath string) error {
	// Do nothing if <reposPath>/doc directory doesn't exist
	docdir := filepath.Join(pathutil.PackReposPathOf(reposPath), "doc")
	if !pathutil.Exists(docdir) {
		return nil
	}
	// Do not invoke vim if not installed
	_, err := exec.LookPath("vim")
	if err != nil {
		return errors.New("vim command is not in PATH: " + err.Error())
	}

	// Find vim executable from PATH
	vimExe, err := pathutil.VimExecutable()
	if err != nil {
		return err
	}
	vimArgs := builder.makeVimArgs(reposPath)

	// Execute ":helptags doc" in reposPath
	logger.Debugf("Executing '%s %s' ...", vimExe, strings.Join(vimArgs, " "))
	err = exec.Command(vimExe, vimArgs...).Run()
	if err != nil {
		return errors.New("failed to make tags file: " + err.Error())
	}
	return nil
}

func (*baseBuilder) makeVimArgs(reposPath string) []string {
	return []string{
		"-u", "NONE", "-N",
		"-c", "cd " + pathutil.PackReposPathOf(reposPath),
		"-c", "set rtp+=" + pathutil.PackReposPathOf(reposPath),
		"-c", "helptags doc", "-c", "quit",
	}
}
