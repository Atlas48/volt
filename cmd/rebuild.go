package cmd

import (
	"crypto/rand"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/vim-volt/go-volt/lockjson"
	"github.com/vim-volt/go-volt/pathutil"
	"github.com/vim-volt/go-volt/transaction"

	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/plumbing"
	"gopkg.in/src-d/go-git.v4/plumbing/object"
)

type rebuildCmd struct{}

func Rebuild(args []string) int {
	// Begin transaction
	err := transaction.Create()
	if err != nil {
		fmt.Println("[ERROR] Failed to begin transaction:", err.Error())
		return 10
	}
	defer transaction.Remove()

	cmd := rebuildCmd{}
	err = cmd.doRebuild()
	if err != nil {
		fmt.Println("[ERROR] Failed to rebuild:", err.Error())
		return 11
	}

	return 0
}

func (cmd *rebuildCmd) doRebuild() error {
	vimDir := pathutil.VimDir()
	startDir := pathutil.VimVoltStartDir()

	// Read lock.json
	lockJSON, err := lockjson.Read()
	if err != nil {
		return errors.New("could not read lock.json: " + err.Error())
	}

	// Get active profile's repos list
	reposList, err := cmd.getActiveProfileRepos(lockJSON)
	if err != nil {
		return err
	}

	fmt.Println("[INFO] Rebuilding " + startDir + " directory ...")
	fmt.Println("[INFO] Installing vimrc and gvimrc ...")

	// Install vimrc and gvimrc
	err = cmd.installRCFile("vimrc.vim", filepath.Join(vimDir, "vimrc"))
	if err != nil {
		return err
	}
	err = cmd.installRCFile("gvimrc.vim", filepath.Join(vimDir, "gvimrc"))
	if err != nil {
		return err
	}

	// Remove start dir
	var removeDone <-chan error
	if _, err := os.Stat(startDir); !os.IsNotExist(err) {
		var err error
		removeDone, err = cmd.removeStartDir(startDir)
		if err != nil {
			return err
		}
	}
	err = os.MkdirAll(startDir, 0755)
	if err != nil {
		return err
	}

	fmt.Println("[INFO] Installing all repositories files ...")

	// Copy all repositories files to startDir
	copyDone := make(chan copyReposResult, len(reposList))
	for i := range reposList {
		go cmd.copyRepos(&reposList[i], startDir, copyDone)
	}

	// Wait remove
	var removeErr error
	if removeDone != nil {
		removeErr = <-removeDone
	}

	// Wait copy
	for i := 0; i < len(reposList); i++ {
		result := <-copyDone
		if result.err != nil {
			return errors.New("failed to copy repository '" + result.repos.Path + "': " + result.err.Error())
		}
	}

	// Show remove error
	if removeErr != nil {
		return errors.New("failed to remove '" + startDir + "': " + removeErr.Error())
	}

	return nil
}

func (cmd *rebuildCmd) installRCFile(srcRCFileName, dst string) error {
	// Skip if rc file does not exist
	src := pathutil.RCFileOf(srcRCFileName)
	if _, err := os.Stat(src); os.IsNotExist(err) {
		return nil
	}

	if _, err := os.Stat(dst); !os.IsNotExist(err) {
		// Return error if the magic comment does not exist
		err := cmd.checkMagicComment(dst)
		if err != nil {
			return err
		}

		// Remove destination (~/.vim/vimrc or ~/.vim/gvimrc)
		os.Remove(dst)
		if _, err := os.Stat(dst); !os.IsNotExist(err) {
			return errors.New("failed to remove " + dst)
		}
	}

	return cmd.copyFileWithMagicComment(src, dst)
}

const magicComment = "\" NOTE: this file was generated by volt. please modify original file.\n"

func (*rebuildCmd) checkMagicComment(dst string) error {
	reader, err := os.Open(dst)
	if err != nil {
		return err
	}
	defer reader.Close()

	magic := []byte(magicComment)
	read := make([]byte, len(magic))
	n, err := reader.Read(read)
	if err != nil {
		return err
	}
	if n < len(magicComment) {
		return errors.New("'" + dst + "' does not have magic comment")
	}

	for i := range magic {
		if magic[i] != read[i] {
			return errors.New("'" + dst + "' does not have magic comment")
		}
	}
	return nil
}

func (*rebuildCmd) copyFileWithMagicComment(src, dst string) error {
	reader, err := os.Open(src)
	if err != nil {
		return err
	}
	defer reader.Close()

	writer, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer writer.Close()

	_, err = writer.Write([]byte(magicComment))
	if err != nil {
		return err
	}

	_, err = io.Copy(writer, reader)
	return err
}

func (cmd *rebuildCmd) removeStartDir(startDir string) (<-chan error, error) {
	// Rename startDir to {startDir}.bak
	oldDir := startDir + ".old" + cmd.randomString()
	err := os.Rename(startDir, oldDir)
	if err != nil {
		return nil, err
	}

	fmt.Println("[INFO] Removing " + startDir + " ...")

	// Remove files in parallel
	done := make(chan error, 1)
	go func() {
		err = os.RemoveAll(oldDir)
		done <- err
	}()
	return done, nil
}

func (*rebuildCmd) randomString() string {
	var n uint64
	binary.Read(rand.Reader, binary.LittleEndian, &n)
	return strconv.FormatUint(n, 36)
}

type copyReposResult struct {
	err   error
	repos *lockjson.Repos
}

func (*rebuildCmd) getActiveProfileRepos(lockJSON *lockjson.LockJSON) ([]lockjson.Repos, error) {
	// Find active profile
	profile, err := lockJSON.Profiles.FindByName(lockJSON.ActiveProfile)
	if err != nil {
		// this must not be occurred because lockjson.Read()
		// validates that the matching profile exists
		return nil, err
	}

	return lockJSON.GetReposListByProfile(profile)
}

func (cmd *rebuildCmd) copyRepos(repos *lockjson.Repos, startDir string, done chan copyReposResult) {
	src := pathutil.FullReposPathOf(repos.Path)
	dst := filepath.Join(startDir, cmd.encodeReposPath(repos.Path))

	r, err := git.PlainOpen(src)
	if err != nil {
		done <- copyReposResult{
			errors.New("failed to open repository: " + err.Error()),
			repos,
		}
		return
	}

	commit := plumbing.NewHash(repos.Version)
	commitObj, err := r.CommitObject(commit)
	if err != nil {
		done <- copyReposResult{
			errors.New("failed to get HEAD commit object: " + err.Error()),
			repos,
		}
		return
	}

	tree, err := r.TreeObject(commitObj.TreeHash)
	if err != nil {
		done <- copyReposResult{
			errors.New("failed to get tree " + commit.String() + ": " + err.Error()),
			repos,
		}
		return
	}

	err = tree.Files().ForEach(func(file *object.File) error {
		osMode, err := file.Mode.ToOSFileMode()
		if err != nil {
			return errors.New("failed to convert file mode: " + err.Error())
		}

		contents, err := file.Contents()
		if err != nil {
			return errors.New("failed get file contents: " + err.Error())
		}

		filename := filepath.Join(dst, file.Name)
		dir, _ := filepath.Split(filename)
		os.MkdirAll(dir, 0755)
		ioutil.WriteFile(filename, []byte(contents), osMode)
		return nil
	})
	if err != nil {
		done <- copyReposResult{err, repos}
		return
	}

	fmt.Println("[INFO] Installing repository " + repos.Path + " ... Done.")

	done <- copyReposResult{nil, repos}
}

func (*rebuildCmd) encodeReposPath(reposPath string) string {
	return strings.NewReplacer("_", "__", "/", "_").Replace(reposPath)
}
